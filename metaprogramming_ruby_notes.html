<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>
      Welcome to the real world
    </title>
    <link rel="stylesheet" href="static/css/bootstrap.css" />
    <link rel="stylesheet" href="static/css/flat-ui.css" />
    <link rel="stylesheet" href="static/css/custom.css" />
    <link rel="stylesheet" href="static/pygments-css/github.css" />
    <link rel="shortcut icon" href="static/images/favicon.ico" />
  </head>
  <body></body>
</html>
<div class="container">
  <h1>
    Start from here
  </h1>
  <div class="row">
    <div class="span6">
      <a class="btn btn-large btn-block" href="/">home</a>
    </div>
    <div class="span6">
      <a class="btn btn-large btn-block" href="/about.html">about</a>
    </div>
  </div>
  <hr /><h1>
  metaprogramming ruby notes
</h1><div id="toc"><ol><li><a href="#object">Object model</a></li><ol><li><a href="#object-class">class and objects</a></li><li><a href="#object-module">class and module</a></li><li><a href="#contants">constants</a></li><li><a href="#object-class-definition">class definition</a></li></ol><li><a href="#macros">Class Macros</a></li><ol><li><a href="#monkey-patch">Monkey See, Monkey Patch</a></li><li><a href="#around-aliases">Around Aliases &lt; Monkey Patch</a></li><li><a href="#singleton-method">Singleton Method</a></li><li><a href="#eigenclasses">Eigenclasses </a></li><li><a href="#class-methods">class methods:</a></li><li><a href="#current-class">The Current Class:</a></li><li><a href="#class-eval">class_eval:</a></li><ol><li><a href="#eval-method">class_eval( ) </a></li><li><a href="#instance-method">instance_eval( ) </a></li></ol></ol><li><a href="#methods">Method call</a></li><ol><li><a href="#methods-lookup">method lookup:</a></li><li><a href="#module-lookup">module lookup:</a></li><li><a href="#self">Discovering self</a></li><li><a href="#private-method">private method</a></li><li><a href="#private">rule</a></li><li><a href="#dynamic-call">Calling Methods Dynamically:</a></li><li><a href="#dispatch">Dynamic Dispatch:</a></li><li><a href="#define">Defining Methods Dynamically:</a></li><li><a href="#dynamic-method">Dynamic Method:</a></li><li><a href="#ghost">Ghost Method:</a></li><li><a href="#dynamic-proxies">Dynamic Proxies:</a></li><li><a href="#blank-slate">Blank Slate:</a></li></ol><li><a href="#block">blocks:</a></li><li><a href="#scope">Scope:</a></li><ol><li><a href="#bindings">bindings and scope</a></li><li><a href="#scope-gates">scope gates:</a></li><li><a href="#flat-scope">flat scope:</a></li><li><a href="#shared-scope">shared scope:</a></li><li><a href="#context">context probe:</a></li><li><a href="#clean-room">clean room:</a></li><li><a href="#callable">Callable Objects:</a></li><ol><li><a href="#deferred">Deferred Evaluation:</a></li><li><a href="#proc-lambda">proc and lambda:</a></li><li><a href="#closure">method:</a></li></ol></ol><li><a href="#wrap-up">Objects and Classes Wrap-Up</a></li><ol><li><a href="#object-wrapup">What’s an object? </a></li><li><a href="#class-wrapup">What’s a class? </a></li></ol><li><a href="#summary">Summary</a></li><li><a href="#rules">Seven rules of the Ruby object model:</a></li></ol></div><h2 id="object">Object model</h2><h3 id="object-class">class and objects</h3><p>Instance variables live in objects, and methods live in<br>classes.</p><pre><code class="highlight">  <span class="nb">String</span><span class="o">.</span><span class="n">instance_methods</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">methods</span>  <span class="c1"># =&gt; true</span>

  <span class="nb">String</span><span class="o">.</span><span class="n">methods</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">methods</span>  <span class="c1"># =&gt; false</span></code></pre><p>classes are nothing but objects, class names are nothing but constants.</p><p>类也是对象，类名则是一些常数值。</p><p>Class有new/instance_methods/methods/superclass/class/ancestors方法</p><p>Classes and regular objects live together</p><br><br><h3 id="object-module">class and module</h3><p>1. Usually, you pick a module when you mean it to be included somewhere (or maybe to be used as a Namespace (41)).<br>2. you pick a class when you mean it to be instantiated or inherited. </p><h3 id="contants">constants</h3><p>all the constants in a program are arranged in a tree similar to a file system, <br>where modules (and classes) are directories and regular constants are files.</p><h3 id="object-class-definition">class definition</h3><p>a Ruby class definition is actually regular code that runs.</p><ul><li>Keep in mind that a class is just a souped-up module.</li><li>The role of the current class is taken by the class of self.</li></ul><br><p>As soon as you enter a new scope, the previous bindings are simply replaced by a new set of bindings. </p><p>定义一个类的时候，self指向当前类,bindings被当前类的bindings替代.</p><br><h2 id="macros">Class Macros</h2><p>All the <code class="highlight">attr_*()</code> methods are defined on class Module, so you can use them<br>whenever self is a module or a class. A method such as <code class="highlight">attr_accessor()</code> is<br>called a Class Macro.</p><p>remember that an attribute is actually a pair of methods</p><h3 id="monkey-patch">Monkey See, Monkey Patch</h3><p>if you casually add bits and pieces of functionality to classes, you can end up with bugs like the one you just encountered. Some people would frown upon this kind of reckless patching of classes, and they would refer to the previous code<br>with a derogatory name: they’d call it a Monkeypatch.</p><h3 id="around-aliases">Around Aliases &lt; Monkey Patch</h3><p>(methods that wrap additional code around other methods).<br>You can write an Around Alias in three simple steps:<br>1. You alias a method.<br>2. You redefine it.<br>3. You call the old method from the new method.</p><quote>As usual, the more powerful the tricks you pull, the more testing of code you need to do!</quote><br><pre><code class="highlight">  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">deprecate</span><span class="p">(</span><span class="n">old_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">)</span>
      <span class="n">define_method</span><span class="p">(</span><span class="n">old_method</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
          <span class="nb">warn</span> <span class="s2">&quot;Warning: </span><span class="si">#{</span><span class="n">old_method</span><span class="si">}</span><span class="s2">() is deprecated. Use </span><span class="si">#{</span><span class="n">new_method</span><span class="si">}</span><span class="s2">().&quot;</span>
          <span class="nb">send</span><span class="p">(</span><span class="n">new_method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
  <span class="k">end</span></code></pre><h3 id="singleton-method">Singleton Method</h3><ul><li>A method specific to a single object, is called a Singleton Method.</li><li>living in the EigenClass of the object.</li></ul><br><h3 id="eigenclasses">Eigenclasses </h3><p>(also known as singleton classes) <br>an object can have its own special, hidden class. <br>That’s called the eigen-class of the object.</p><p>eigenclasses have only a single instance<br>(that’s why they’re also called singleton classes).and they can’t be inherited. <br>More important, an eigenclass is where an object’s Singleton<br>Methods live</p><br><h3 id="class-methods">class methods:</h3><p>they’re Singleton Methods of a class. </p><ul><li>Class methods are a special kind of Singleton Method</li></ul><br><p>class methods are just Singleton Methods that live in the class’s<br>eigenclass, you can just open the eigenclass and define the<br>method in there:</p><pre><code class="highlight">  <span class="k">class</span> <span class="nc">MyClass</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
      <span class="k">def</span> <span class="nf">my_method</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre><p>eigenclass helper:</p><pre><code class="highlight">  <span class="k">class</span> <span class="nc">Object</span>
    <span class="k">def</span> <span class="nf">eigenclass</span>
      <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span><span class="nb">self</span><span class="p">;</span><span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre><p>eigenclass and inheritance:<br>The superclass of the eigenclass is the eigenclass of the superclass.</p><h3 id="current-class">The Current Class:</h3><p>Whenever you open a class with the class keyword(or a module with the module keyword),that class becomes the current class.<br>(the default home of the methods you define).</p><ul><li>In a class definition, the current object self is the class being</li></ul><p>defined.</p><ul><li>The Ruby interpreter always keeps a reference to the current class</li></ul><p>(or module). All methods defined with def become instance methods of the current class.</p><ul><li>In a class definition, the current class is the same as self—the class</li></ul><p>being defined.</p><ul><li>If you have a reference to the class, you can open the class with</li></ul><p><code class="highlight">class_eval()</code> (or <code class="highlight">module_eval()</code>).</p><br><h3 id="class-eval">class_eval:</h3><h5 id="eval-method">class_eval( ) </h5><p>changes both self and the current class.<br>By changing the current class, class_eval( ) effectively reopens the class, just like the class keyword does.</p><h5 id="instance-method">instance_eval( ) </h5><p>only changes self.<br>in fact,instance_eval( ) also changes the current class: <br>it changes it to the eigenclass of the receiver.</p><h2 id="methods">Method call</h2><p>When you call a method, Ruby does two things:</p><p>1. It finds the method. This is a process called <code class="highlight">method lookup</code>.<br>2. It executes the method. To do that, Ruby needs something called<br><code class="highlight">self</code>.</p><h3 id="methods-lookup">method lookup:</h3><p>When you call a method, Ruby looks into the object’s class and finds the method there.</p><ul><li>ancestors chain: The path of classes you just traversed is the ancestors chain of the class. (The ancestors chain also includes modules)</li><li>To find a method, Ruby goes in the receiver’s class, and from there</li></ul><p>it climbs the ancestors chain until it finds the method.</p><h3 id="module-lookup">module lookup:</h3><ul><li>When you include a module in a class (or even in another module),</li></ul><p>Ruby creates an <code class="highlight">anonymous class</code> that wraps the module and inserts the anonymous class in the chain, just above the including class itself</p><ul><li>wrapper classes are called <code class="highlight">include classes</code> (or sometimes proxy</li></ul><p>classes).</p><ul><li>class Object includes Kernel, so Kernel gets into every object’s ancestors chain.</li><li>if you add a method to Kernel, this Kernel Method will be available to all objects.</li></ul><br><br><h3 id="self">Discovering self</h3><p>Every line of Ruby code is executed inside an object—the so–called current object. <br>The current object is also known as self, because you can access it with the self keyword.</p><ul><li>When you call a method, Ruby looks up the method by following the <code class="highlight">one step to the right, then up</code> rule and then</li></ul><p>executes the method with the receiver as self. </p><h3 id="private-method">private method</h3><ul><li>every time you call a private method, it must be on the implicit receiver—self.</li></ul><br><h3 id="private">rule</h3><p>1.you need an explicit receiver to call a method on an object that is not yourself<br>2.private methods can be called only with an implicit receiver. <br>SO you can only call a private method on yourself. </p><br><br><h3 id="dynamic-call">Calling Methods Dynamically:</h3><p>using either Dynamic Methods or a special method called method_missing()<br>my mentors told me that when you call a method, you’re actually sending a<br>message to an object.</p><h3 id="dispatch">Dynamic Dispatch:</h3><p>With send( ), the name of the method that you want to call becomes just a regular argument. You can<br>wait literally until the very last moment to decide which method to call,<br>while the code is running. This technique is called Dynamic Dispatch<br>Pattern Dispatch:<br>it filters methods based on a pattern in their names</p><br><h3 id="define">Defining Methods Dynamically:</h3><h3 id="dynamic-method">Dynamic Method:</h3><p>This technique of defining a method at runtime is called a Dynamic Method</p><h3 id="ghost">Ghost Method:</h3><p>A message that’s processed by method_missing( ) looks like a regular call<br>from the caller’s side but has no corresponding method on the receiver’s<br>side. This is named a Ghost Method. <br>Ghost Methods like rows_with_country( ) are just syntactic sugar; they<br>can’t do anything that a regular method couldn’t.</p><ul><li>don’t introduce more Ghost Methods than necessary</li></ul><br><br><h3 id="dynamic-proxies">Dynamic Proxies:</h3><p>An object that catches Ghost Methods and forwards them to another ob-<br>ject, maybe wrapping some logic around the call, is called a Dynamic<br>Proxy.</p><h3 id="blank-slate">Blank Slate:</h3><ul><li>Classes that inherit directly from BasicObject are automatically Blank Slates.</li></ul><br><p>remove most inherited methods from your proxies right away.<br>The result is called a Blank Slate, a class that has fewer methods than<br>the Object class itself</p><pre><code class="highlight">  <span class="n">undef_method</span><span class="p">()</span> <span class="o">/</span> <span class="n">remove_method</span><span class="p">()</span>
  <span class="nb">instance_methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
    <span class="n">undef_method</span> <span class="n">m</span> <span class="k">unless</span> <span class="n">m</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/^__|method_missing|respond_to?/</span>
  <span class="k">end</span></code></pre><h2 id="block">blocks:</h2><p>blocks are a powerful tool for controlling scope, meaning which variables and methods can be seen by which lines of code.</p><ul><li>Code that runs is actually made up of two things: the code itself and a set of bindings.</li></ul><p>When code runs, it needs an environment: local variables, instance variables,<br>self. . . . </p><ul><li>Since these entities are basically names bound to objects, you</li></ul><p>can call them the bindings for short. </p><h2 id="scope">Scope:</h2><h3 id="bindings">bindings and scope</h3><p>when you create the block, you capture the local bindings.<br>A block captures the bindings that are around when you first define the block. You can also define additional bindings inside the block, but they disappear after the block ends.</p><p>The first time the program enters my_method( ), it opens a new scope and defines a local variable. <br>Then the program exits the method, falling back to the top-level scope.</p><br><ul><li>&quot;Whenever the program changes scope, some bindings are replaced by a new set of bindings.&quot;</li></ul><br><p>Granted, this doesn’t happen to all the bindings each and every time.<br>For example, if a method calls another method on the same object,<br>instance variables stay in scope through the call. <br>In general, though,bindings tend to fall out of scope when the scope changes. In particular, local variables change at every new scope. (That’s why they’re “local”!)&quot;</p><h3 id="scope-gates">scope gates:</h3><p>There are exactly three places where a program leaves the previous<br>scope behind and opens a new one:</p><ul><li>Class definitions</li><li>Module definitions</li><li>Methods</li></ul><br><p>Being less universally accessible, top-level instance variables are generally considered safer than global variables</p><p>The code in a class or module definition is executed immediately. <br>Conversely, the code in a method definition is executed later, when you eventually call the method. </p><p>不能从内看到外面的本地变量</p><h3 id="flat-scope">flat scope:</h3><p>If you replace Scope Gates with methods, you allow one scope to see<br>variables from another scope. <br>Technically, this trick should be called <code class="highlight">nested lexical scopes</code></p><ul><li>Class.new( ) is a perfect replacement for class.</li></ul><p>You can also define instance methods in the class if you pass a block to <code class="highlight">Class.new( )</code></p><ul><li>Instead of def, you can use <code class="highlight">Module#define\_method( )</code></li></ul><br><h3 id="shared-scope">shared scope:</h3><p>No other method can see shared, because it’s protected by a Scope Gate<br>That’s what the define_methods( ) method is for. This smart way<br>to control the sharing of variables is called a <code class="highlight">Shared Scope</code>.</p><h3 id="context">context probe:</h3><p>you can call the block that you pass to instance_eval( ) a Context Probe, because it’s like a snippet of code that you dip inside an object to do something in there,but it also allows you to pass arguments to the block</p><br><h3 id="clean-room">clean room:</h3><p>Sometimes you create an object just to evaluate blocks inside it. An<br>object like that can be called a Clean Room:</p><pre><code class="highlight">  <span class="n">env</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
  <span class="n">env</span><span class="o">.</span><span class="n">instance_eval</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">env</span><span class="o">.</span><span class="n">instance_eval</span> <span class="o">&amp;</span><span class="n">event</span></code></pre><p>The instance variables in the setups and events are actually instance variables of the Object. <br>This is the trick that allows setups to define variables for events</p><br><h3 id="callable">Callable Objects:</h3><h5 id="deferred">Deferred Evaluation:</h5><p>you can create a Proc by passing the block to Proc.new. Later, you can<br>evaluate the block-turned-object with Proc#call( )</p><ul><li>you can use the &amp;operator to convert the Proc to a block</li></ul><br><h5 id="proc-lambda">proc and lambda:</h5><ul><li>In a lambda, return just returns from the lambda.</li><li>In a proc, return behaves differently. Rather than return from the proc,</li></ul><p>it returns from the scope where the proc itself was defined</p><ul><li>Call a lambda with the wrong arity, and it fails</li></ul><p>with an ArgumentError. On the other hand, a proc fits the argument list<br>to its own expectations<br>p = -&gt;(x) { x + 1 }(haskell way)</p><h5 id="closure">method:</h5><ul><li>By calling Object#method( ), you get the method itself as a Method object,</li></ul><p>which you can later execute with Method#call().</p><ul><li>You can detach a method from its object with Method#unbind( ), which</li></ul><p>returns an UnboundMethod object.</p><br><br><br><br><h2 id="wrap-up">Objects and Classes Wrap-Up</h2><h3 id="object-wrapup">What’s an object? </h3><p>It’s just a bunch of instance variables, plus a link to a class. <br>The object’s methods don’t live in the object—they live in the object’s class, where they’re called the instance methods of the class.</p><br><h3 id="class-wrapup">What’s a class? </h3><p>It’s just an object (an instance of Class), plus a list of instance methods and a link to a superclass. <br>Class is a subclass of Module, so a class is also a module.</p><p>Like any object, a class has its own methods, such as new( ). <br>These are instance methods of the Class class. <br>Also like any object, classes must be accessed through references. <br>You already have a constant reference to each class: the class’s name.</p><br><br><h2 id="summary">Summary</h2><ul><li>An object is composed of a bunch of instance variables and a link</li></ul><p>to a class.</p><ul><li>The methods of an object live in the object’s class (from the point</li></ul><p>of view of the class, they’re called instance methods).</p><ul><li>The class itself is just an object of class Class. The name of the</li></ul><p>class is just a constant.</p><ul><li>Class is a subclass of Module. A module is basically a package of</li></ul><p>methods. In addition to that, a class can also be instantiated (with<br>new( )) or arranged in a hierarchy (through its superclass( )).</p><ul><li>Constants are arranged in a tree similar to a file system, where</li></ul><p>the names of modules and classes play the part of directories and<br>regular constants play the part of files.</p><ul><li>Each class has an ancestors chain, beginning with the class itself</li></ul><p>and going up to BasicObject.</p><ul><li>When you call a method, Ruby goes right into the class of the</li></ul><p>receiver and then up the ancestors chain, until it either finds the<br>method or reaches the end of the chain.</p><ul><li>Every time a class includes a module, the module is inserted in</li></ul><p>the ancestors chain right above the class itself.</p><ul><li>When you call a method, the receiver takes the role of self.</li><li>When you’re defining a module (or a class), the module takes the</li></ul><p>role of self.</p><ul><li>Instance variables are always assumed to be instance variables of</li></ul><p>self.</p><ul><li>Any method called without an explicit receiver is assumed to be a</li></ul><p>method of self. </p><ul><li>There are classes, eigenclasses, and modules.</li></ul><p>There are instance methods, class methods, and Singleton Methods.</p><br><br><h2 id="rules">Seven rules of the Ruby object model:</h2><p>1. There is only one kind of object—be it a regular object or a module.<br>2. There is only one kind of module—be it a regular module, a class,<br>an eigenclass, or a proxy class.<br>3. There is only one kind of method, and it lives in a module—most<br>often in a class.<br>4. Every object, classes included, has its own “real class,” be it a<br>regular class or an eigenclass.<br>5. Every class has exactly one superclass, with the exception of Basi-<br>cObject (or Object if you’re using Ruby 1.8), which has none. This<br>means you have a single ancestors chain from any class up to<br>BasicObject.<br>6. The superclass of the eigenclass of an object is the object’s class.<br>The superclass of the eigenclass of a class is the eigenclass of the<br>class’s superclass. (Try repeating that three times, fast! Then look<br>back at Figure 4.5, on the preceding page, and it will all make<br>sense.)<br>7. When you call a method, Ruby goes “right” in the receiver’s real<br>class and then “up” the ancestors chain. That’s all there is to know<br>about the way Ruby finds methods.</p><br><br><br><br><br><br>
</div>
<footer>
  <div class="container">
    <div class="row">
      <div class="span7">
        <h3 class="footer-title">
          Built with <a href="http://krazylee.github.io/hashup">Hashup</a> proundly
        </h3>
        <p>
          Do you like this freebie? Want to get more stuff like this?<br /> Subscribe to designmodo news and updates to stay tuned on great designs.<br />
        </p>
      </div>
    </div>
  </div>
</footer>
